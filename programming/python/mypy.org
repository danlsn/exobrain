#+TITLE: Mypy tips and tricks
#+logseq_title: mypy
#+filetags: :python:mypy:

* [#B] [2019-01-01] use ~--check-untyped-defs~                         :mypy:
:PROPERTIES:
:ID:       schckntypddfs
:END:


* TODO [#C] [2019-10-26] [[https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type][reveal_type]] can be used during the type checking
:PROPERTIES:
:ID:       smypyrdthdcsnltstcmmnssshvltypcnbsddrngthtypchckng
:END:
=reveal_type(a)  # N: Revealed type is 'builtins.int'=
: https://github.com/python/mypy/blob/09c243dcc12935b989367f31d1d25d7fd0ec634c/test-data/unit/check-python38.test

* [#C] [2019-12-07] [[https://www.reddit.com/r/Python/comments/8hmjq9/the_other_great_benefit_of_python_type_annotations/dyl1wjt][hack for preventing unnecessary module imports]]
:PROPERTIES:
:ID:       swwwrddtcmrpythncmmntshmjkfrprvntngnncssrymdlmprts
:END:
Type annotation will require importing modules that you wouldn't need to import without it. However there is now a workaround (quote the name and import in a dead if):

: if False:
:     from bar_module import bar
: 
: def foo(a: 'bar'):
:      pass

* TODO [#B] [2019-10-27] how should type of lru_cache be defined
:PROPERTIES:
:ID:       hwshldtypflrcchbdfnd
:END:
https://github.com/python/mypy/issues/5107

: from typing import TYPE_CHECKING, TypeVar
: if TYPE_CHECKING:
:     F = TypeVar('F', Callable)
:     def lru_cache(f: F) -> F: pass
: else:
:     from functools import lru_cache


* TODO [#C] [2018-10-12] https://mypy.readthedocs.io/en/latest/additional_features.html#dataclasses-support
:PROPERTIES:
:ID:       smypyrdthdcsnltstddtnlftrshtmldtclsssspprt
:END:
* STRT [#C] should use ~mypy --namespace-packages~ more often?         :mypy:
:PROPERTIES:
:CREATED:  [2019-11-13]
:ID:       shldsmypynmspcpckgsmrftn
:END:
** [2020-03-27] actually they're looking into making it a default
:PROPERTIES:
:ID:       ctllythyrlkngntmkngtdflt
:END:
* TODO [#D] [2019-04-16] mypy overloads                                :mypy:
:PROPERTIES:
:ID:       mypyvrlds
:END:
: @overload
: def fetch_data(raw: Literal[True]) -> bytes: ...
: @overload
: def fetch_data(raw: Literal[False]) -> str: ...
: # Fallback overload if the user provides a regular bool
* TODO use protocols for classes which I can't control, they are very neat!!! :python:mypy:habit:
:PROPERTIES:
:CREATED:  [2018-12-11]
:ID:       a57ea940-d567-4a15-8a12-1c02fb3116d5
:END:


* [2019-03-12] shit, looks like python can import without __init__ files, but mypy can't handle lack of them :( :python:
:PROPERTIES:
:ID:       shtlkslkpythncnmprtwthtntflsbtmypycnthndllckfthm
:END:
* TODO Python Type Hints – NP-Incompleteness                           :mypy:
:PROPERTIES:
:CREATED:  [2019-12-30]
:ID:       pythntyphntsnpncmpltnss
:END:

https://kunigami.blog/2019/12/26/python-type-hints/amp/?__twitter_impression=true

Good mypy intro?

* TODO [#B] __init__ file is useful for mypy submodule discovery..     :mypy:
:PROPERTIES:
:CREATED:  [2019-12-21]
:ID:       ntflssflfrmypysbmdldscvry
:END:

* TODO [#C] https://github.com/wemake-services/wemake-python-styleguide/blob/master/styles/mypy.toml :mypy:
:PROPERTIES:
:CREATED:  [2019-11-09]
:ID:       sgthbcmwmksrvcswmkpythnstylgdblbmstrstylsmypytml
:END:

* STRT [#C] stricter mypy in my code                                   :mypy:
:PROPERTIES:
:CREATED:  [2019-07-25]
:ID:       strctrmypynmycd
:END:
: --strict                  Strict mode; enables the following flags:
: 
: --warn-unused-ignores
: --warn-redundant-casts
: 
: --warn-unused-configs
: --disallow-subclassing-any
: --disallow-any-generics
: --disallow-untyped-calls
: --disallow-untyped-defs
: --disallow-incomplete-defs
: --check-untyped-defs
: --disallow-untyped-decorators
: --no-implicit-optional
: --warn-return-any


mypy --warn-unused-ignores --warn-redundant-casts --check-untyped-defs kcache.py
* TODO [#C] right, sys.version info is also evalueated?         :mypy:errors:
:PROPERTIES:
:CREATED:  [2019-12-08]
:ID:       rghtsysvrsnnfslsvltd
:END:
: if sys.version_info[1] < 7: vs having it in a variable
* TODO [#C] hmm, apparently function parameter/argument names are taken into account??? :mypy:
:PROPERTIES:
:CREATED:  [2019-12-07]
:ID:       hmmpprntlyfnctnprmtrrgmntnmsrtknntccnt
:END:
:  def testx(x: int) -> None:
:      pass
: 
:  def testy(y: int) -> None:
:      pass
: 
:  test = testx
:  test = testy
* STRT [#C] get_origin/get_args                                        :mypy:
:PROPERTIES:
:CREATED:  [2019-12-08]
:ID:       gtrgngtrgs
:END:
:  def get_origin(tp):
:      """Get the unsubscripted version of a type.
: 
:      This supports generic types, Callable, Tuple, Union, Literal, Final and ClassVar.
:      Return None for unsupported types. Examples::
: 
:          get_origin(Literal[42]) is Literal
:          get_origin(int) is None
:          get_origin(ClassVar[int]) is ClassVar
:          get_origin(Generic) is Generic
:          get_origin(Generic[T]) is Generic
:          get_origin(Union[T, int]) is Union
:          get_origin(List[Tuple[T, T]][int]) == list
:      """
:      if isinstance(tp, _GenericAlias):
:          return tp.__origin__
:      if tp is Generic:
:          return Generic
:      return None
: 
: 
:  def get_args(tp):
:      """Get type arguments with all substitutions performed.
: 
:      For unions, basic simplifications used by Union constructor are performed.
:      Examples::
:          get_args(Dict[str, int]) == (str, int)
:          get_args(int) == ()
:          get_args(Union[int, Union[T, int], str][int]) == (int, str)
:          get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
:          get_args(Callable[[], T][int]) == ([], int)
:      """
:      if isinstance(tp, _GenericAlias):
:          res = tp.__args__
:          if get_origin(tp) is collections.abc.Callable and res[0] is not Ellipsis:
:              res = (list(res[:-1]), res[-1])
:          return res
:      return ()
** TODO Mypy get_args and get_origin
:PROPERTIES:
:CREATED:  [2019-12-06]
:ID:       mypygtrgsndgtrgn
:END:

* [#C] [2020-03-22] MonkeyType: A system for Python that automatically generates type annotations | Hacker News
:PROPERTIES:
:ID:       mnkytypsystmfrpythnthttmtcllygnrtstypnnttnshckrnws
:END:
https://news.ycombinator.com/item?id=22624845
:  Check out mypy with "--no-any-expression" flag and Pydantic.
* WAIT [#D] error with reusing exception variable                      :mypy:
:PROPERTIES:
:CREATED:  [2018-08-22]
:ID:       rrrwthrsngxcptnvrbl
:END:
: try:
:   pass
: except Exception as e:
:   pass
: 
: for e in []:
:   pass


https://github.com/python/mypy/issues/5080
* [#D] [2019-10-12] Protocols and structural subtyping — Mypy 0.740+dev.34fe00b4f9220fa9a939be1a80cf5acc3479da9a.dirty documentation
:PROPERTIES:
:ID:       prtclsndstrctrlsbtypngmypydvfbffbcfccddrtydcmnttn
:END:
https://mypy.readthedocs.io/en/latest/protocols.html
: isinstance() also works with the predefined protocols in typing such as Iterable.
* TODO [#D] [2019-04-16] The Mypy Blog: Mypy 0.700 Released: Up To 4x Faster
:PROPERTIES:
:ID:       thmypyblgmypyrlsdptxfstr
:END:
https://mypy-lang.blogspot.com/2019/04/mypy-0700-released-up-to-4x-faster.html
: We are now shipping a mypy binary compiled with mypyc by default, which is up to 4x faster than the interpreted version shipped previously. The compiled version has been available as a separate PyPI distribution for a while now, and this is first release where it’s installed by default. Mypyc is a compiler that compiles type-annotated Python modules into efficient CPython C extension modules.
* [#D] [2018-06-20] __all__ and pycharm and mypy                       :mypy:
:PROPERTIES:
:ID:       llndpychrmndmypy
:END:
TLDR: messing with __all__ results in problems, don't do that..
I guess I have to be careful on module levels then if I don't want unwanted crap...

* [#B] [2020-05-03] [[https://github.com/python/mypy/issues/3157#issuecomment-502434084][Support function decorators excellently · Issue #3157 · python/mypy]]
:PROPERTIES:
:ID:       sgthbcmpythnmypyssssscmmndcrtrsxcllntlysspythnmypy
:END:
: Just for the record: if someone needs to change the return type of the function inside the decorator and still have typed parameters, you can use a custom mypy plugin that literally takes 15 LoC: https://github.com/dry-python/returns/blob/92eda5574a8e41f4f5af4dd29887337886301ee3/returns/contrib/mypy/decorator_plugin.py
: 
: Saved me a lot of time!
* [#B] [2020-05-25] [[https://github.com/python/mypy/issues/1927][Making a decorator which preserves function signature · Issue #1927 · python/mypy]] :mypy:
:PROPERTIES:
:ID:       sgthbcmpythnmypysssmkngdcsrvsfnctnsgntrsspythnmypy
:END:
: from typing import Any, Callable, TypeVar
: FuncT = TypeVar('FuncT', bound=Callable[..., Any])

ok, this + overrides allowed me to type it properly
* STRT [#C] [2020-10-05] [[https://www.python.org/dev/peps/pep-0585/][PEP 585 -- Type Hinting Generics In Standard Collections | Python.org]]
:PROPERTIES:
:ID:       swwwpythnrgdvppspppptyphnnrcsnstndrdcllctnspythnrg
:END:
: Starting with Python 3.7, when from __future__ import annotations is used, function and variable annotations can parameterize standard collections directly. Example:
* TODO [#D] seems like a bug in fbmessenger export (on a branch)       :mypy:
:PROPERTIES:
:CREATED:  [2020-01-13]
:ID:       smslkbgnfbmssngrxprtnbrnch
:END:
* [2020-05-06] [[https://mypy.readthedocs.io/en/stable/protocols.html#using-isinstance-with-protocols][Protocols and structural subtyping — Mypy 0.770 documentation]] :mypy:
:PROPERTIES:
:ID:       smypyrdthdcsnstblprtclshtstrctrlsbtypngmypydcmnttn
:END:
: You can use a protocol class with isinstance() if you decorate it with the @runtime_checkable class decorator. The decorator adds support for basic runtime structural checks:
* CANCEL [#C] PathIsh thing can be generalized to Path constructible   :mypy:
:PROPERTIES:
:CREATED:  [2019-05-02]
:ID:       pthshthngcnbgnrlzdtpthcnstrctbl
:END:
** [2019-06-28] not sure if __init__ would do well? https://mypy.readthedocs.io/en/latest/protocols.html
:PROPERTIES:
:ID:       ntsrfntwlddwllsmypyrdthdcsnltstprtclshtml
:END:
** [2019-08-24] eh, so os.PathLike[str] kinda solves it, but using .pyi file for that is not really worth it
:PROPERTIES:
:ID:       hsspthlkstrkndslvstbtsngpyflfrthtsntrllywrtht
:END:
* TODO [#D] shit. I don't get why there is a difference between checking source and directly??? :mypy:
:PROPERTIES:
:CREATED:  [2020-09-12]
:ID:       shtdntgtwhythrsdffrncbtwnchckngsrcnddrctly
:END:
: $ mypy my/endomondo.py
: my/endomondo.py:8: error: Skipping analyzing '.core.common': found module but no type hints or library stubs  [import]
:     from .core.common import Paths, get_files
:     ^
: my/endomondo.py:8: note: See https://mypy.readthedocs.io/en/latest/running_mypy.html#missing-imports
: my/endomondo.py:39: error: Skipping analyzing '.core.error': found module but no type hints or library stubs  [import]
:     from .core.error import Res
:     ^
: my/endomondo.py:54: error: Skipping analyzing '.core': found module but no type hints or library stubs  [import]
:         from .core import stat
:     ^
: Found 3 errors in 1 file (checked 1 source file)
: $ mypy -p my.endomondo
: my/endomondo.py: note: In function "workouts":
: my/endomondo.py:48: error: Incompatible types in "yield" (actual type "endoapi.endomondo.Workout", expected type "Union[my.endomondo.Workout, Exception]")  [misc]
:                 yield w
:                 ^
: Found 1 error in 1 file (checked 1 source file)
* TODO [#D] that's odd, behaviour when checking package vs files is different :mypy:
:PROPERTIES:
:CREATED:  [2019-06-02]
:ID:       thtsddbhvrwhnchckngpckgvsflssdffrnt
:END:
 mypy wereyouhere/extractors/custom.py
wereyouhere/extractors/custom.py:56: error: Unexpected keyword argument "line" for "make" of "Loc"
wereyouhere/extractors/custom.py:144: error: Too few arguments for "make" of "Loc"
 mypy wereyouhere

* TODO [#D] [2019-04-12] Using installed packages — Mypy 0.710+dev.d920bd7c76bda5ad29fd4fb994ef7be5f85cec1f.dirty documentation :python:mypy:
:PROPERTIES:
:ID:       sngnstlldpckgsmypydvdbdcbddfdfbfbfccfdrtydcmnttn
:END:
https://mypy.readthedocs.io/en/latest/installed_packages.html
py.typed for injector?
* TODO [#B] [2019-11-02] Type hints for naive/aware datetime objects? : Python :datetime:mypy:
:PROPERTIES:
:ID:       typhntsfrnvwrdttmbjctspythn
:END:
https://www.reddit.com/r/Python/comments/79vddc/type_hints_for_naiveaware_datetime_objects
** [2019-12-20] use NewType for that?
:PROPERTIES:
:ID:       snwtypfrtht
:END:
: ndt = NewType('ndt', datetime.datetime)
: dt = NewType('dt', datetime.datetime)
: 
: def dt_to_ndt(dt: dt) -> ndt:
:     pass


* TODO [#C] disallow generic any could be good...                      :mypy:
:PROPERTIES:
:CREATED:  [2020-05-25]
:ID:       dsllwgnrcnycldbgd
:END:
* TODO [#C] [2020-08-19] [[https://mypy.readthedocs.io/en/stable/running_mypy.html][Running mypy and managing imports — Mypy 0.782 documentation]] :mypy:
:PROPERTIES:
:ID:       smypyrdthdcsnstblrnnngmyppyndmngngmprtsmypydcmnttn
:END:
: Finally, any command-line argument starting with @ reads additional command-line arguments from the file following the @ character. This is primarily useful if you have a file containing a list of files that you want to be type-checked: instead of using shell syntax like:
* STRT [#C] [2019-12-30] Show HN: FastAPI: build Python APIs with Go-like speed and automatic UI docs | Hacker News :mypy:
:PROPERTIES:
:ID:       shwhnfstpbldpythnpswthglkspdndtmtcdcshckrnws
:END:
https://news.ycombinator.com/item?id=19441195
: tiangolo 9 months ago [-]
: To use Python type hints, and get automatic data validation, serialization, and documentation for your API (including interactive UI docs for your API). All that, even for deeply nested JSON bodies. And by using type hints, you get autocomplete everywhere, type error checks, etc.
: Your API gets documented with standards: OpenAPI and JSON Schema.
: Or to be able to have WebSockets.
: Or for its dependency injection system, that saves you a lot of code and plugins.
: You can check the features here: https://fastapi.tiangolo.com/features/
: And you can see alternatives and comparisons here: https://fastapi.tiangolo.com/alternatives/
** [2020-03-01] ok, nice, so it uses mypy types, not custom types (like hug?)
:PROPERTIES:
:ID:       kncstssmypytypsntcstmtypslkhg
:END:
* STRT [#C] [2020-05-15] [[https://dmerej.info/blog/post/hello-flake8/][Hello flake8 • Dimitri Merejkowsky]] :pylint:mypy:
:PROPERTIES:
:ID:       sdmrjnfblgpsthllflkhllflkdmtrmrjkwsky
:END:
: Itamar Turner-Trauring 2, in the comment section on dev.to gave an interesting example:

handling closures
* [#C] [2020-04-13] [[https://news.ycombinator.com/item?id=22854380][For sure! Black and isort complement each other in *formatting* your code, and ... | Hacker News]] :mypy:
:PROPERTIES:
:ID:       snwsycmbntrcmtmdfrsrblcknhthrnfrmttngyrcdndhckrnws
:END:
: warn_return_any,
* [#C] [2020-03-12] pydantic                                    :python:mypy:
:PROPERTIES:
:ID:       pydntc
:END:
https://pydantic-docs.helpmanual.io/
: If validation fails pydantic will raise an error with a breakdown of what was wrong:
: from pydantic import ValidationError
: 
: try:
:     User(signup_ts='broken', friends=[1, 2, 'not number'])
: except ValidationError as e:
:     print(e.json())
* [#C] [2020-06-22] [[https://news.ycombinator.com/item?id=22305446][We've been running mypy on our project for about a year now and it's one of the ... | Hacker News]] :mypy:
:PROPERTIES:
:ID:       snwsycmbntrcmtmdwvbnrnnngctfrbtyrnwndtsnfthhckrnws
:END:
: We implemented it progressively. At first I added it as a make target but didn't make it mandatory in CI so I could learn how to use it. Then I made it mandatory for a few files that I was the only active contributor to. Then I slowly added more and more files across the project, sometimes as I touched them for other reason and other times as independent changes. Eventually as mypy caught more and more bugs in other contributor's changes they started getting on board and adding type hints as well, until the vast majority of the project was hinted (we'll be getting to 100% within a few weeks).
* [#D] [2019-12-07] Still alive? · Issue 25 · machinalis/mypy-data :mypy:numpy:
:PROPERTIES:
:ID:       stlllvssmchnlsmypydt
:END:
https://github.com/machinalis/mypy-data/issues/25

* TODO [#C] [2019-12-08] pytester's comments | Hacker News             :mypy:
:PROPERTIES:
:ID:       pytstrscmmntshckrnws
:END:
https://news.ycombinator.com/threads?id=pytester
some very reasonable thoughts on typing from this guy
* TODO mypy + multiple python versions                                 :mypy:
:PROPERTIES:
:CREATED:  [2020-10-31]
:ID:       mypymltplpythnvrsns
:END:
this is mypy friendly
: if sys.version_info[:2] >= (3, 8):

this isn't
: if sys.version_info.minor >= 7:
* [#C] [2020-12-08] [[https://hakibenita.com/python-mypy-exhaustive-checking#type-narrowing-in-mypy][Exhaustiveness Checking with Mypy | Haki Benita]]
:PROPERTIES:
:ID:       shkbntcmpythnmypyxhstvchchstvnsschckngwthmypyhkbnt
:END:

* [#C] [2019-12-08] Statically-typed error handling in Python using Mypy | Hacker News :errors:mypy:
:PROPERTIES:
:ID:       sttcllytypdrrrhndlngnpythnsngmypyhckrnws
:END:
https://news.ycombinator.com/item?id=21736620
: My approach is to dial up strictness gradually as code proves its value. I'll start out building a project and not validating on I/O, but as the requirements get locked down and the code has proven itself, I'll clean up all the edge cases - which will often mean adding in progressively stricter validation on border code.
: The advantage of this is that if you end up not wasting too much time "building the wrong thing". Let's say that you took one form of I/O and built massively strict validation in and then realized later that you should have taken an entirely different form of I/O for your subsystem. All that time building in validation on that useless part of code was a pointless waste.
: I don't have any stats, but my gut feel is that on average 40% of code can end up being tossed in this way (in some projects it's 100% =).
: Prototyping speed is, additionally, not just useful in reducing the cost of building the right kind of code, it's useful in reducing the cost of building the right kind of test (a really underappreciated facet of building mission critical systems).

In my younger years I used to believe that for mission critical systems "building the wrong thing" was somehow less of a problem in code because you could fix requirements and do architecture upfront with some sort of genius architect. Turns out this was wrong.
* [2019-10-24] Our journey to type checking 4 million lines of Python : programming :mypy:
:PROPERTIES:
:ID:       rjrnyttypchckngmllnlnsfpythnprgrmmng
:END:
https://www.reddit.com/r/programming/comments/d16aa4/our_journey_to_type_checking_4_million_lines_of/

* [#C] tried this https://github.com/predictive-analytics-lab/data-science-types, seems to give many false positives... :pandas:mypy:
:PROPERTIES:
:CREATED:  [2020-10-03]
:ID:       trdthssgthbcmprdctvnlytcsscnctypssmstgvmnyflspstvs
:END:
* [#C] [2019-08-31] Define a JSON type · Issue #182 · python/typing    :mypy:
:PROPERTIES:
:ID:       dfnjsntypsspythntypng
:END:
https://github.com/python/typing/issues/182
: With that and the idea of string self referencing, JSONType can be defined as:
: 
: from typing import Recursive, Union, List, Dict
: 
: JSONType = Recursive(
:     "JSONType",
:     Union[int, float, str, bool, None, List["JSONType"], Dict[str, "JSONType"]]
: )
* [#C] [2019-08-31] Define a JSON type · Issue #182 · python/typing    :mypy:
:PROPERTIES:
:ID:       dfnjsntypsspythntypng
:END:
https://github.com/python/typing/issues/182
: Unless I'm mistaken, recursive types with ForwardRefs can already be checked correctly at runtime by using ForwardRef._evaluate(globals(), locals())
* [#B] [2020-02-05] Applying mypy to real world projects               :mypy:
:PROPERTIES:
:ID:       pplyngmypytrlwrldprjcts
:END:
http://calpaterson.com/mypy-hints.html
** [2020-02-07] good
:PROPERTIES:
:ID:       gd
:END:

* [#C] [2020-11-25] [[https://github.com/python/mypy/issues/1362][Decorated property not supported · Issue #1362 · python/mypy]]
:PROPERTIES:
:ID:       sgthbcmpythnmypysssdcrtdprprtyntspprtdsspythnmypy
:END:
: As a workaround, you could try defining your own alias to the property decorator that is annotated to return Any. If you use your custom property decorator (that at runtime behaves exactly like property) for all decorated properties, mypy will silently give all such properties the Any type.
* [#D] [2019-12-08] Statically-typed error handling in Python using Mypy | Hacker News https://news.ycombinator.com/item?id=21736620
:PROPERTIES:
:ID:       sttcllytypdrrrhndlngnpythpyhckrnwssnwsycmbntrcmtmd
:END:
: Third party libraries: I sometimes see them annotated, but what people don't suspect, is that you need to include 'py.typed' file with your package in order for it to be discoverable. Perhaps that's something setuptools could warn the developer about..
* [#D] [2019-12-12] Statically-typed error handling in Python using … - Reddit https://www.reddit.com/r/Python/comments/e971w5/staticallytyped_error_handling_in_python_using/
:PROPERTIES:
:ID:       sttcllytypdrrrhndlngnpythllytypdrrrhndlngnpythnsng
:END:
