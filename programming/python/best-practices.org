#+TITLE: 
* testing
** nose is abandoned
** pytest is the best apparently
- uses the built in =assert=
  : assert 1 == 1, 'This is my error message, which is optional'
- parameterized tests
- fixtures: These aren't the setup/teardown fixtures (per-se), but more like dependency injection (and are incredibly useful). You can even inject a fixture into a fixture (say you need to log in a user, but you need an HTTP client for it to work, you probably use that client elsewhere so DRY it up):
- markers: Easy way to categorize tests (and coincidentally run only those groups)
  : @pytest.mark.slow
  : def test_slow_running_thing():
  :     time.sleep(500)
- parallel execution via xdist

* logging
** simple
import logging
logging.basicConfig(level=logging.INFO) # apparently callin basicconfig at least one is important
logging.exception('Caught an error' + str(e))

** use logzero for nice colored logs

* json
** json.dump(jobj, stdout, indent=4, sort_keys=True, ensure_ascii=False)


* TODO asyncio
